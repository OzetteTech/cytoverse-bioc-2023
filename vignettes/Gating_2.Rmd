---
title: "Gating Cells in cytoverse: Part 2"
vignette: >
  %\VignetteIndexEntry{Gating Cells}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Using openCyto gatingTemplate 

In [**Part 1**](Gating_1.Rmd) we identified various gates available in `cytoverse` and how to use them. Here, we show how users can compose a similar gating scheme by using  a `gatingTemplate`. 

A `gatingTemplate` is a csv file that describes the gating sequence and the gating methods. In the `gatingTemplate` csv file, we can leverage the various automated gating methods that we have previously seen, without explicitly requiring to script it in **R**.

Let's take a look at an example `gatingTemplate`

```{r gatingTemplate_load, echo=TRUE, eval= TRUE, message = FALSE}
# load gatingTemplate csv
gt_file <- get_workshop_data("gating_template/")

knitr::kable(read.csv(gt_file$rpath))
```

### Required columns

There are 10 columns that are required in a gatingTemplate csv file:

  - **alias# **: name (alias) of the gate
  - **pop# **: + or -; a combination such as: --, -+, ++, +-; *. 
  - **parent# **: parent population
  - **dims# **: channels or markernames
  - **gating_method# **: gating method to be used. example: *mindensity*
  - **gating_args**: additional arguments that can be passed to **gating_methods**
  - **collapseDataForGating**: **logical** indicating if the data is to be collapsed onto a single `flowFrame` before estimation
  - **groupBy**: string indicating the grouping variable (within `pData` slot of the `GatingSet`)
  - **preprocessing_method**: preprocessing method to be used
  - **preprocessing_args**: additional arguments that can be passed to **preprocessing_method**

*Note:* # indicates that these fields must be completed. Others can be left blank.

### Writing a `gatingTemplate` csv file

Above, It should be apparent that the each row of the `gatingTemplate` csv file is akin to the function call to a specific type of gate. 

Let's take a look at a simple example of the node `singlet`:

  - `alias`: singlet *name of the gate*
  - `pop`: + *indicating that we want events inside the gate*
  - `parent`: root *indicating the parent population*
  - `dims`: FSC-A,FSC-H *indicating the channels that the function should use*
  - `gating_method`: singletGate *indicating the gating method*
  - `gating_args`:wider_gate=FALSE,prediction_level=0.95	*indicating a tight gate*
  - `collapseDataForGating`: FALSE *indicating not to collapse the entire `GatingSet` into 1 `flowFrame` for estimation*
  - `groupBy`: NA *indicating that no grouping is to be done*
  - `preprocessing_method`: NA *indicating that no preprocessing is to be done*
  - `preprocessing_args`: NA *indicating that no preprocessing argument is specified*




Let's parse this csv file into a `gatingTemplate` object

```{r gatingTemplate_show, echo=TRUE, eval = TRUE,message=FALSE}
# required library
library(openCyto)

# directly read in a csv
gt <- openCyto::gatingTemplate(gt_file$rpath)
```

Now that we have `gt` we should first visualize the hierarchy to confirm that it matches our expectations! To achieve this we use `plot`. Let's plot `gt` and compare it to the `GatingSet` we created earlier.

```{r plot_gt, echo=TRUE, eval=TRUE, message=FALSE}
# show gt
plot(gt)

# show gs
plot(gs)
```

Since we have saved our `GatingSet` let's first remove all the nodes including and downstream of `singlet`.

```{r gatingTemplate_run, echo = TRUE, eval = FALSE, message = FALSE}
# clean gs
gs_pop_remove(gs, "singlet") # removes singlet and all children nodes
recompute(gs)

# add gates defined in gatingTemplate
gt_gating(gt, gs) # simply provide the parsed gatingTemplate and the GatingSet
recompute(gs)

# visualize Gating Hierarchy
plot(gs, bool = TRUE)

# hide helper gates
gt_toggle_helpergates(gt,gs)

# surface MAIT Cells
gs_pop_set_visibility(gs,
                      c("MAIT Cells"),
                      TRUE)

# visualize the full gated data
autoplot(gs[[2]], bool = TRUE, bins = 128)+
  ggcyto_par_set(limits = "data")
```

