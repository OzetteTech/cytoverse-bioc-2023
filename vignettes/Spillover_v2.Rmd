---
title: "Spillover, compensation, Transformations, and Visualization (1)"
output: rmarkdown::html_vignette
runtime: shiny
---

```{r,include=FALSE, echo=FALSE,eval=TRUE}
library(ggcyto)
library(flowCore)
library(openCyto)
library(flowWorkspace)
library(flowStats)
theme_set(theme_bw())
```

# Background

In this section, we aim to clarify the concept of Spillover, and the use of spillover/compensation matrices to correct for this. The last part of this section will deal with various transformations of the underlying expression data.

## Spillover

[CLARIFY THIS FURTHER] Flow cytometers (optics based: spectral or non-spectral) collect fluorescent signal from a cell as result of a laser excitation. Briefly, cell type C has been labelled with a marker M that is conjugated to a fluorophore (F). F has the property that it is excitation maxima at certain wavelength (W) resulting in fluoroscence. While the fluoresence has a emmision maxima, the emission profile of F can span many nanometers. The cytometer has a dedicated detector (channel) A to detect peak emission of F. However, due to the spread of the emission of F, some signal from F is also "spilled" onto detector B, a detector for a different fluorophore.

The image below provides a concrete example.

![Excitation/Emission spectra for FITC. Taken from Bio-Rad. A is the dedicated detector for FITC. B is a secondary detector where FITC signal spills over.](https://static.bio-rad-antibodies.com/2016/flow-cytometry/fig-9-spectral-profiles.png)

The "spillover" of signal onto secondary detector(s) is additive and can be easily recovered (more on this below).

Raw Signal in B = Signal from FITC (spillover) + Signal for a dedicated fluorophore.

Signal recovery (Compensation) requires a set of controls be present to calculate the spillover. These controls are called **Single Colour Controls** and are often acquired prior to sample acquisition. The purpose of the single colour control is to estimate the amount of spillover of emission from fluorophore F onto non-primary detectors (detector B in the image above).

[TO ADD INFORMATION ABOUT SPECTRAL] Note: ABOUT Spectral instruments are set up slightly differently...

## Importance of spillover correction

Let's visualize the data to highlight the main issues related to spillover. I am using the `ggcyto` library from the `cytoverse`. We will dive into more details on the usage of `ggcyto` in a later section.

```{r viz_uncompensated_data, echo=FALSE, eval=T, message=FALSE, fig.width=10}
# load required libraries
library(flowCore)
library(ggcyto)

# read file
ff <- read.FCS("data/fcs_data/4000_BDC-CR1.fcs")[,-32]

# define transformation
trans <- transformList(from = names(markernames(ff)),tfun = (function(x)asinh(x/500)))
# transform
ff_trans <- transform(ff,trans)

# plot
uncompensated <- as.ggplot(ggcyto(ff_trans, aes(x = "CD3", y = "CD5"))+
  geom_hex(bins = 128)+
  theme_bw()+
  labs(title = "Uncompensated data"))

# compensate
ff_comp <- compensate(ff, spillover(ff)[[3]])
# transform
ff_comp <- transform(ff_comp,trans)

# plot
compensated <- as.ggplot(ggcyto(ff_comp, aes(x = "CD3", y = "CD5"))+
  geom_hex(bins = 128)+
  theme_bw()+
  labs(title = "Compensated data")+
    axis_x_inverse_trans())

gridExtra::grid.arrange(uncompensated,compensated,nrow = 1, top = "1. Difficulty resolving the correct populations")

```

Another example:

```{r uncompensated_data_issue,echo=FALSE,eval=TRUE, fig.width=10}

uncompensated <- as.ggplot(ggcyto(ff_trans, aes(x = "SSC-A", y = "Live"))+
  geom_hex(bins = 128)+
  theme_bw()+
  labs(title = "Uncompensated data"))

compensated <- as.ggplot(ggcyto(ff_comp, aes(x = "SSC-A", y = "Live"))+
  geom_hex(bins = 128)+
  theme_bw()+
  labs(title = "Compensated data"))

gridExtra::grid.arrange(uncompensated, compensated, nrow = 1, top = "2. Wrong conclusions")

```

In example 1,the plot first plot shows the uncompensated data. In this example, the 2 fluorophores: PE-Cy5 and PE-Cy5.5 are spilling onto each other, making the data not resolvable. However, after correcting for spillover, we see that the data can be resolved (2nd plot).

In example 2, we see a population of events that are positive of marker: Live Dead UV Blue. Generally, these events are discarded as this marker is used to identify dead cells. However, in correctly compensated data, we see that this population does not exist!

## Where to find your spillover matrix?

In many cases, the spillover matrix (which is used to correct the spillover) is attached to the FCS files within `$SPILLOVER`,`SPILL`,or `SPILL` keywords. In `cytoverse`, we can check for the presence of by using the function `spillover(ff)`.

Example:

```{r show_spill, echo=T, message=TRUE}
# show spillover
spillover(ff)
```

We notice a few important details. - `spillover(ff)` returns all 3 keywords, even if some do not contain a matrix - It is not necessary that all 3 keywords have a matrix - spillover matrix is square. This is because the user will run 1 single colour control for each channel/marker they intend to acquire. In this example its 28 x 28

The columns of the spillover matrix are the detectors while the rows are contribution from each fluorophore. Visualizing it as a heatmap is sometimes more helpful

```{r explain_spillover, echo=FALSE, eval=TRUE, fig.height=10, fig.width=10}
# extract spillover
s.mat <- spillover(ff)[[3]]
rownames(s.mat) <- markernames(ff)

pheatmap::pheatmap(mat = s.mat,cluster_rows = F,cluster_cols = F,color = colorRampPalette(c("black","orange","cyan","magenta"))(100),display_numbers = T,number_format = "%.2f",legend = FALSE,number_color = "white")
```

Looking at the figure, column 2: B610-A has high spillover from flurophore: PE-Dazzle594 and PE.

In fact, when we look at the emission spectrum of the 2 dyes we see that this issue is apparent:

![Spectra from PE and BB630P2.](images/spectrumChart.png) The image was created at <https://www.bdbiosciences.com/en-ca/resources/bd-spectrum-viewer> using the BD spectrum viewer tool.

### Calculating spillover from single colour controls

Another way to calculate spillover is by using a set of single colour controls. This is generally a part of experiment/instrument set up before acquisition begins.

Generally, there ought to be the same number of single colour controls as the number of markers being assessed + 1 unstained to estimate the background autofluoresence of cells.

The dataset that we are primarily going to be working with (i.e. [FR-FCM-Z5PC](https://flowrepository.org/public_experiment_representations/5932)) did not come with a set of control files to generate the spillover matrix. So for demonstration purposes, we will use single colour controls from a different dataset [FR-FCM-ZZ36](https://flowrepository.org/id/FR-FCM-ZZ36).

```{r generating_spillover_with_controls, echo=TRUE, eval =TRUE, message=FALSE}
# required libraries
library(flowCore)

# load sample fcs files
ff <- read.FCS("data/FlowRepository_FR-FCM-ZZ36_files/pbmc_luca.fcs")

# load csv identifying the mapping of control files
control_files <- read.csv("data/FlowRepository_FR-FCM-ZZ36_files/control_files.csv",row.names = 1)

# load the set of compensation files
comp_frames <- lapply(file.path("data", "FlowRepository_FR-FCM-ZZ36_files",control_files[["filename"]]),read.FCS)
names(comp_frames) <- control_files[["channel"]]

# convert to flowSet
comp_fs <- as(comp_frames,"flowSet")


# quick visualization of what the control files contain
all_control_af488 <- ggcyto::as.ggplot(ggcyto(comp_fs,
                  aes(x = "FSC-A", y = "Alexa Fluor 488-A"))+
                    geom_hex(bins = 256)+
                    theme_bw()+
                    scale_y_flowCore_fasinh(b = 1/150)+
                    labs(title = "Detection of Alexa Fluor 488 in all control samples "))

# calculate spillover
## using spillover from flowStats
spill <- flowStats::spillover(comp_fs,
                   unstained = "Unstained", # indicate how the unstained file is named in flowset
                   patt = "-A", # indicate which parameter should be considered 
                   fsc = "FSC-A",
                   ssc = "SSC-A",
                   stain_match = "regexpr",useNormFilt = TRUE)
```

Now, let's visualize the spill matrix that we calculated.

[NOTE: This needs to be corrected in the flowStats package. Normalization is with respect to the max value and not with respect to the intended channel.]

```{r viz_calculated_spill, eval=T, echo=FALSE}
pheatmap::pheatmap(mat = spill,cluster_rows = F,cluster_cols = F,color = colorRampPalette(c("black","orange","cyan","magenta"))(100),display_numbers = T, legend = FALSE, number_color = "white",number_format = "%.3f")

```

*Note: "Close or related fluorophores will have some degree of overlap"*

Lastly, we check the effect of "compensating" the files.

```{r show_comp_effect, echo=T, eval=TRUE}
# read in FCS
ff <- read.FCS("data/FlowRepository_FR-FCM-ZZ36_files/pbmc_luca.fcs")
trans <- flowCore::transformList(from = setdiff(sampleNames(comp_fs),"Unstained"),
                                 tfun = flowCore::arcsinhTransform(b = 1/150)
                                 )
ff_trans <- transform(ff,trans) # transformation defined above

# plot pre-compensation
pre_compensation <- as.ggplot(autoplot(ff_trans, 
                                       x = "PE-Cy5-5-A", 
                                       y = "PE-Cy5-A", 
                                       bins = 256)+
                                labs(title = "Uncompensated data")
                              )

# compensate
ff_comp <- compensate(ff,final)
ff_comp <- transform(ff_comp,trans)

# plot post-compensation
post_compensation <- as.ggplot(autoplot(ff_comp,
                                       x = "PE-Cy5-5-A", 
                                       y = "PE-Cy5-A", 
                                       bins = 256)+
                                 labs(title = "Compensated data")
                               )

gridExtra::grid.arrange(pre_compensation, post_compensation, nrow = 1)
```

## Transformation and visualization

Cytometry data tends to have a very high dynamic range. For example: the range of values in PE-Cy5-5-A channel in the FCS we have been working with is `r range(ff)[,"PE-Cy5-5-A", drop = FALSE]`. The difference between cells that do not express a marker of interest and a cell that expresses variable level of marker could be order of magnitude difference. In such a scenario, transformation of the data can aid in better visualization and representation of the biological phenomenan.

There are multiple approaches to transform the data in `cytoverse`. We will identify a few common ones as well as demonstrate how to create new transformations.

First, let's visualize why transformation is necessary.

```{r transformation_demo, echo=FALSE, eval=FALSE,message=FALSE,}
library(shiny)
ff <- read.FCS("data/fcs_data/4000_BDC-CR1.fcs")
ff <- compensate(ff, spillover(ff)[[3]])
channels <- markernames(ff)[setdiff(colnames(ff),c(paste("FSC-",c("A","W","H"),sep = ""),
                           paste("SSC-",c("A","W","H"),sep = ""),
                             "Time"))]
names(channels) = NULL
transformations <- c("inverse hyperbolic sin", "biexponential","log","No transformation")
log_trans <- flowWorkspace::flowjo_log_trans()
transformation_list <- list("biexponential" = list("x-axis" = scale_x_flowjo_biexp(),
                                                            "y-axis" = scale_y_flowjo_biexp()),
                            "inverse hyperbolic sin" = list("x-axis" = scale_x_flowjo_fasinh(),
                                                            "y-axis" = scale_y_flowjo_fasinh()),
                             "logicle" = list("x-axis" = scale_x_logicle(),
                                                            "y-axis" = scale_y_logicle()),
                            "log" = list("x-axis" = scale_x_continuous(name = "log_trans_x",
                                                                       breaks = log_trans$breaks,trans = log_trans
                                                                       ),
                                         "y-axis" = scale_y_continuous(name = "log_trans_y",
                                                                       breaks = log_trans$breaks,trans = log_trans
                                                                       )),
                            "No transformation" = list("x-axis" = scale_x_continuous(),
                                         "y-axis" = scale_y_continuous()))
plot_transformation <- function(flowFrame, transformation,channels = NULL){
  physical_parameters <- c(paste("FSC-",c("A","W","H"),sep = ""),
                           paste("SSC-",c("A","W","H"),sep = ""),
                             "Time")
  #fluor.channels <- colnames(flowFrame)[colnames(flowFrame %in% physical_parameters)]
  trans <- transformation_list[[transformation]]
  if(!is.null(channels)){
    transformed_plot <- 
      autoplot(
      flowFrame, 
      x = channels[1],
      y = channels[2],
      bins = 256
    )+
      trans[[1]]+
      trans[[2]]+
      theme(axis.text = element_text(face = "bold", colour = "red"),
           )+
      labs(title = "Data has been compensated")
    transformed_plot
  }
}
shinyApp(
  ui = fluidPage(
    selectInput(inputId = "transformation",
                label = "Select Transformation",choices = transformations,selected = "No transformation",multiple = FALSE),
    selectInput(inputId = "channels_x",
                label = "X-axis",
                choices = channels,
                selected = channels[1],
                multiple = FALSE),
    selectInput(inputId = "channels_y",
                label = "Y_axis",
                choices = channels,
                selected = channels[2],
                multiple = FALSE),
    plotOutput("ggcyto")
  ),
  
  server = function(input, output){
    output$ggcyto = 
      renderPlot({
        plot_transformation(flowFrame = ff,transformation = input$transformation,channels = c(input$channels_x,input$channels_y))
      },height = 400,width = 400)
  }
  ,
  options = list(height = 700)
  
)


```

```{r demo_transformations, echo=FALSE, eval=T, fig.width=10, fig.height=10}
ff <- read.FCS("data/fcs_data/4000_BDC-CR1.fcs")
ff <- compensate(ff, spillover(ff)[[3]])

no_transform <- as.ggplot(autoplot(ff,
         x = "CD14",
         y = "HLA-DR",
         bins = 256)+
  labs(title = "No transformation applied"))

biexp <- as.ggplot(autoplot(ff,
         x = "CD14",
         y = "HLA-DR",
         bins = 256)+
  scale_x_flowjo_biexp()+
  scale_y_flowjo_biexp()+
  labs(title = "Biexponential transformation"))

log_trans <- as.ggplot(autoplot(ff,
         x = "CD14",
         y = "HLA-DR",
         bins = 256)+
  scale_x_continuous(trans = flowWorkspace::flowjo_log_trans())+
  scale_y_continuous(trans = flowWorkspace::flowjo_log_trans())+
  labs(title = "Log transformation"))

asinh_t <- as.ggplot(autoplot(ff,
         x = "CD14",
         y = "HLA-DR",
         bins = 256)+
  scale_x_flowjo_fasinh()+
  scale_y_flowCore_fasinh()+
  labs(title = "inverse hyperbolic sine transformation"))

logicle <- as.ggplot(autoplot(ff,
         x = "CD14",
         y = "HLA-DR",
         bins = 256)+
  scale_x_logicle()+
  scale_y_logicle()+
  labs(title = "Logicle transformation"))

gridExtra::grid.arrange(no_transform,biexp, log_trans,asinh_t, logicle, nrow = 2,bottom = "Generic transformations of compensated data")
```

As we see, the variety of transformations aids in visualization and interpretation of the data.

Steps to transform FCS data

-   `cytoverse` libraries: `flowWorkspace` and `flowCore` have a multiple commonly used transformations as well, one can also create a custom transformation if required.

```{r how_to_transform_builtin, echo=T, eval=T, message=F}
# transforming using cytoverse functions
# define a transformation

asinh_trans <- flowWorkspace::asinh_Gml2(T = sinh(1)*500,M = 0.4)
# create a transformList that indicates which parameters to transform
my_trans_list <- flowCore::transformList(from = names(markernames(ff)),
                                         tfun = asinh_trans)


# transform 
ff_transformed <- flowCore::transform(ff, my_trans_list)

# visualize
ff_comp <- as.ggplot(
  autoplot(ff,
           x = "CD14", 
           y = "HLA-DR",
           bins = 256)
)

ff_comp_transformed <- as.ggplot(
  autoplot(ff_transformed,
           x = "CD14",
           y = "HLA-DR",
           bins = 256)
)

gridExtra::grid.arrange(ff_comp, ff_comp_transformed, nrow = 1)

```

User defined transformation.

```{r user_defined_transformation,echo=TRUE,eval=TRUE}
# define a transformation
my_trans <- function(x){
  return(sqrt(abs(x)))
}

# create a transformList
my_trans_list <- flowCore::transformList(from = names(markernames(ff)), 
                                         tfun = my_trans)

# transform
ff_transformed <- transform(ff, my_trans_list)

# visualize
ff_comp_transformed <- as.ggplot(
  autoplot(ff_transformed,
           x = "CD14",
           y = "HLA-DR",
           bins = 256)
)

gridExtra::grid.arrange(ff_comp, ff_comp_transformed, nrow = 1)

```

Transforming a set of FCS files

```{r transform_flowset, echo=TRUE, eval=TRUE}
# read in a flowSet
fs <- flowCore::read.flowSet(path = "data/fcs_data/",pattern = "BDC-CR1")

# compensate
fs <- fsApply(fs, function(x){
  spill = spillover(x)[[3]]
  compensate(x,spillover = spill)
})

# using asinh_trans defined previously
my_trans_list <- flowCore::transformList(from = names(markernames(ff)),
                                         tfun = asinh_trans)
# using the same approach as shown previously
fs_transformed <- transform(fs, my_trans_list)

# visualize
fs_raw <- as.ggplot(autoplot(fs,
                   x = "CD14",
                   y = "HLA-DR",
                   bins = 256)+
  labs(title = "Untransformed flowSet"))

fs_trans <- as.ggplot(autoplot(fs_transformed,
                     x = "CD14",
                     y = "HLA-DR",
                     bins = 256)+
  labs(title = "Transformed flowSet"))

gridExtra::grid.arrange(fs_raw, fs_trans)
```

Transformation of `cytoset` take a slightly different (but mostly similar) path.

```{r trans_cytoset, echo=TRUE, eval=TRUE}
# load a cytoset from fcs files
cs <- flowWorkspace::load_cytoset_from_fcs(path = "data/fcs_data/",pattern = "BDC-CR1")

# compensate
spill <- spillover(cs[[1]])[[3]] 
cs <- compensate(cs, spill)

# transform: this will transform the underlying data 
transform(cs,my_trans_list)
```
